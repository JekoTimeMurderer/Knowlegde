*{
	/*margin: 0;
	padding: 0;*/
}



.container{
	width: 300px;
	height: 300px;
	margin: 50px auto;
	border: 3px solid black;
}

										/*box-sizing:border-box*/

/*В хроме паддинги и бордеры не входят в стандартную ширину блока
и когда мы их задаем, то они расширяют наш блок увеличивая его 
размеры своими. В IЕ6, например, паддинги и бордеры откладываются 
во внутрь не расширяю сам блок. Существует цсс свойство в хроме
позволяющее откладывать бордеры и паддинг во внутрь блока (как в IE6).
Это свойство box-sizing:border-box; Если же мы задали свойство
box-sizing:border-box и хотим, чтобы этот блок откладывался от границ
своего родителя, то можно это сделать с помощью margin.Если мы хотим вместить
наш блок не используя свойство box-sizing:border-box, то в этом случае
нужно просто сумму всех отступов отнять от ширины блока или грубо говоря
учесть все отступы при задании ширины нашему блоку.
Существуют еще 2 cвойства box-sizing:1) content-box (то, что у нас по умолчанию
	т.е. widh и height не включает в себя значение padding, margin, border.
2)padding-box (widh и height включает в себя значение padding,но не 
border и margin).	*/

/*Кстати, всегда в цсс нужно писать разчмер (px или %), кроме html, например,
когда мы задаем размер картинки, там просто пишем размерность без единиц
измерения.*/

.d4{
	box-sizing:border-box;
	width: 100%;	
	padding-left: 30px;
	padding-right: 10px;
	border: 10px solid orange;

	/*margin-left: 10px;*/
	/*margin-top: 10px;*/

}

																/*Накладывание margin*/
/*Если бы мы задали нашим 4-ем блокам p margin-top: 10px; и margin-bottom: 10px;
то по нормальной логике между блоками должно было бы быть 20px растояния
(10 верхнего от нижнего блока и 10 нижнего от верхнего блока, вместе 20), но
на практики получается не 20, а 10px.(только между блоками) 
Это происходит потому, что margin имеет свойства накладываться.
Итак, если у нас 2 margina топ и боттом заданые вместе, то они оба
не будут действовать, а будет действовать тот, чью значение больше. Этот ньюанс
просиходит только между блоками, по краям (крайние сверху или снизу)
все происходит адекватно. Также следует заметить, что	отступы ГОРИЗОНТАЛЬНЫЕ
никогда не складываются ни у строчных ни у блочных елементов.	*/


p{
margin-top: 10px;	
margin-bottom: 0px;
/*background-color: red;*/
}

ul{
list-style-type: none;
font-size: 40px;
}

/*Замечаем особенность: у инлайновых елементов (строчных) нету возможности
регулировать отступы(только margin, с паддинг все норм) по высоте 
(margin top/bottom), только по горизонтали.*/
/*Можно добавить что существуют так называемые замещяемые елементы(img,input), которые не
реагируют, когда им задают display:block и width: auto. Это происходит потому,
что они замещаются на нечто уже имеющее свои параметры. например тег img 
будет замещен на какую-то картинку имеющую свою высота/ширину и она не сможет
растянуться на всю доступную ширину экрана также как и инпут.(submit или text*/

/*Иногда удобно задавать отрицательные margin для того, чтобы добиться каких-то
специфических результатов.*/


/*Кстати, margin: 0 auto; выравнивает по середине блок только по горизонтале, не
по вертикале ничего не произойдет.*/

li{
	display: inline;
	background-color: red;
	margin-right: 20px;
}

	/*Нижний пример показывает, что margin-top у блока в процентах берется не от
	высоты, а от ширины. Это можно увидить в нижнем примере, когда при 
	высоте вложенного блока 100%  margin-top 50% делает отступ не на 50%, а на 
	100%.*/


.container2{
	height: 300px;
	width: 600px;
	border: 3px solid black;
}


.d{
	width: 50px;
	height: 100px;
	/*margin-top: auto;*/
	margin-top: 50%;
	background: red;
}

/*Ниже показано, что line-height и font-size заданные родителю применяются
ко всем вложенным в него елементам даже если у них разные классы. Но мы 
можем переопределять эти свойства (line-height и font-size) если обратимся 
к ним. Кстати, line-height можно задать не только в пикселях, но и просто в
цифрах. Стандартный line-height 1.2 .*/

.wrapper{
	line-height: 40px;
	font-size: 30px;
}

/*Cуществует понятие base line, котороя является линией на которой как бы стоят
все слова в строке и цсс свойство vertical-align(middle/top/bottom) как 
раз позволяет изменить это.*/

/*span{
	color: red;
	vertical-align: 25px; Выравниваем по вертикали(плюс 25 вверх,а -25 вниз)
}*/

/*По умолчанию span - это инлайновый елемент, которому мы не можем задать 
ни высоту ни ширину ни марджины, если мы зададим ему display:block, то все
у нас будет в столбик, но если мы применим display:inline-block, то мы сможем
к нему применить все свойства блочного елемена при этом он будет вести себя 
как строчный.*/


span{
	font-size: 40px;
	color: pink;
	height: 200px;
	width: 200px;
	margin: 10px;
	background: orange;
	display: inline-block;
	/*vertical-align: bottom;*/
}

.lol{
	height: 100px;
	vertical-align: middle: ;
}

/*Треугольник*/


.triangle{
	width: 0;
	height: 0;
	border: 55px solid;
	border-color: transparent transparent cyan transparent;
}

/*Интересный момент, color задает цвет не только для шрифта, но и для
border если для него не указан собственный цвет.*/



/*Устанавливает, будет ли прокручиваться фоновое изображение вместе с содержимым элемента. 
Изображение может быть зафиксировано  и оставаться неподвижным, либо 
перемещаться совместно с документом.*/

.attach{
	width: 1000px;
	height: 2000px;
	background-image: url(http://avatars.mds.yandex.net/get-yablogs/51778/VJ6GvNYde/orig);
	background-repeat: no-repeat;
	background-attachment: fixed;	
	background-position: 50% 50%;
	background-color: #ccc;
}

/*Интересный момент: для того, чтобы что-то торчащим из блока нужно применить
отрицательный margin.;*/