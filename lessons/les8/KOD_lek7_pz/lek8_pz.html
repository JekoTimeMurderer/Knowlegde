<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>lek8_pz</title>

<link rel="stylesheet" href="lek8_pz_css/lek8_pz.css">

</head>
<body>
	
															<!-- Transition

Данное свойство устанавливает эффект перехода (плавного) между двумя состояниями элемента (цвет либо позиционирование), они могут определены с помощью псевдоэлемента :hover или :active, а также динамически через javascript. Т.е. когда мы делаем эффект перехода с помощью hoverа например, то это происходит моментально, но с помощью transition эти переходы между состояниями цвета/позиционирования происходят плавно.
В самом transtion, вначале мы прописываем 1)transition-property(Устанавливает имя стилевого свойства, значение которого будет отслеживаться для создания эффекта перехода) т.е. перечисляем свойства какие хотим "транзишинить" т.е. на какие свойства мы хотим накладывать ту самую плавность, в нашем примере (см. внизу) мы хотим, чтобы изменялся плавно background-color. После того как мы прописали transition-property т.е. свойства, которые хотим "транзишинить" (в нашем примере это background-color) мы указываем 2)transition-duration(Задаёт время в секундах или миллисекундах, сколько должна длиться анимация перехода до её завершения. По умолчанию значение равно 0s, это означает, что никакой анимации нет, переход происходит мгновенно. Можно указать несколько значений, перечисляя их через запятую. Каждое значение применяется к свойствам, заданным через transition-property.) т.е. время за которое будет осуществляться переход от одного состояние к другому (в нашем случае это 0.3s). После задание времени в нашем примере мы указываем 3)transition-timing-function(Устанавливает, насколько быстро должно изменяться значение стилевого свойство для которого применяется эффект перехода.transition-timing-function представляет собой математическую функцию, показывающую, как быстро по времени меняется указанное через transition-property значение свойства. Начальная точка имеет координаты 0.0, 0.0, конечная — 1.0, 1.0, при этом функция по оси ординат может превышать эти значения в большую или меньшую сторону ) т.е. каким образом будет происходить переход (функция перехода). Также в конце может указываться 4)transition-delay(Свойство transition-delay устанавливает время ожидания перед запуском эффекта перехода. Значение 0s или 0ms запускает анимацию сразу же. Отрицательное значение также включает анимацию без задержек, но может привести к изменению вида начала анимации.Допустимо указывать несколько значений, перечисляя их через запятую. Каждое значение будет применяться к свойству, заданному в параметрах transition-property.) Также следует отметить transition:all -  значения transition по умолчанию. Оно часто применяется к элементам, в которых мы хотим, чтобы все свойства, которые видоизменяею наш элемент подвергались transition т.е. плавному переходу. И тогда нужно еще после all указать время (к примеру 0.3s) и transition-timing-function (к примеру linear).-->

<!-- Первый пример -->

<!-- <div></div> -->

<!-- Второй пример -->

<!-- <div></div> -->

<!-- Третий пример -->

<!--  В этом примере показывается наглядно, что из себя представляет свойство time-function. Т.е. если представить себе плавный переход состояния элемента от 0 к 1, то time-function - это по сути 4 точки перехода на этом пути, которые мы можем указать. см. пример ниже -->
	

<!-- <div><img src="http://www.w3.org/TR/css3-transitions/TimingFunction.png" alt="OMG!!!"></div> -->

<!-- Пример с использованием всех свойств transition
Еще раз напомним, что свойство transition-delay позволяет
	делать задержку перед началом анимации. -->

<!-- <div></div> -->

																	<!-- Transformation 
transform - это свойство применимое к БЛОЧНЫМ и сточным элементам, которое позволяет маштабировать, вращать, сдвигать, наклонять элемент, а также комбинировать все эти свойства.
Стоить заметить, что место, которое занимал занимал элемент до трансформации остается, также как и в случае относительного позиционирования. Через свойство трансформации можно задать:1)МАТРИЦУ преобразований (transform:matrix),2)ПОВОРОТ элемента на заданный угол относительно точки трансформации(transform:rotate(<угол>), 3)задание МАШТАБА элемента полностью по х и по у (transform:scale() либо же по отдельности: сначала по x (transform:scaleX() или по у transform:scaleY()) 4)НАКЛОН элемента на заданный угол по вертикале (transform:skewX) либо по горизонтале (transform:skewY). 5)СДВИГ элемента на заданное значение по вертикале и по горизонтале (transform:translate()) либо же по отдельности по х (transform:translateX()) либо по у (transform:translateY())
Также следует отметить, что вместе с самим блоком трансформируется и все его содержимое (см. пример ниже)
-->

<!-- <div><h1>AAA</h1></div> -->

<!-- Также существует свойство transform-origin (устанавливает координаты точки, относительно которой будет происходить трансформация элемента), прописывается как transform-origin: <x> <y> <z>. Итак, изначально, у этого свойства значения Х - 50% и Y - 50%, т.е. в центре элемента, но мы можем задать например 0 0 и тогда наш элемент будет трансформироваться не относительно своего центра, а относительно верхней левой точки, либо если мы зададим 100% по Х и 100% по У, то тогда наш элемент будет трансформироваться относительно правой нижней точки.
Последнее, третье свойство связанное с transform - transform-style. Оно определяет, как дочерние элементы будут отображаться в 3D-пространстве. transform-style может быть в значениях flat(по умолчанию) и в preserved-3d (которое отображает элемент в 3d пространстве). -->
	
<!-- Пример по transition/transformation -->

<!-- <div class="demo2d">
  <div class="demo2d__demo demo2d__demo_pos_t"></div>
  <div class="demo2d__demo demo2d__demo_pos_b"></div>
  <div class="demo2d__demo demo2d__demo_pos_l"></div>
  <div class="demo2d__demo demo2d__demo_pos_r"></div>
  <div class="demo2d__demo demo2d__demo_pos_f"></div>
  <div class="demo2d__demo demo2d__demo_pos_z"></div>
</div> -->

<!-- Также не все новые свойства могут прописываться без вентерных префиксов и в идеале, нам нужно для всех все новый свойства писать в нескольких вариантах: допустим, для хрома/мазилы/и просто, без вентерных префиксов. Также существует автопрефиксинг, это обычно отдельные программы (автопрефексеры css), которые автоматически добавляет венторные префиксы, что является необычайно удобно. -->

																	<!-- Animation 
animation - универсальное свойство, которое задаёт сразу несколько параметров анимации. Как и у transition/transformation у animation тоже существует ряд своих параметров:1) animation-name (в данном свойстве задается 1)имя анимации и 2)создаются  ключевые кадры (последовательность движения или то что будет происходить в самой анимации)анимации. Оба этих действия(1,2) работают через правило @keyframes(Правило @keyframes устанавливает ключевые кадры при анимации элемента, которые должны применятся к элементу в заданный момент времени, при этом ключевые кадры - это свойства элемента такие как прозрачность, цвет, положение и др., в нашем примере это margin-left. Таким образом анимация представляет собой плавный переход стилевых свойств от одного ключевого кадра к другому.).Таким образом после @keyframes собственно и прописывается вначале 1)имя самой анимации (в нашем примере это my_custom_name), а потом прописывается последовательность движения анимации. Ключевые кадры анимации (или последовательность её движений) в @keyframes задается через ключевые слова from (от, аналогичен 0%) и to (до аналогичен 100%). Самый простой вариант, когда у нас есть только 2 ключевых кадра - исходное и конечно состояние. В таком случае последовательность анимации или ключевые кадры анимации через @keyframe запишутся таким образом: 
																		@keyframe box {
																		from {left: 0;}
																		to {left: 300px;}																
В данном случае box - это имя нашей анимации, (которое позже мы пропишем в самом свойстве animation) и ниже мы устанавливаем, что наш box т.е. наша анимация будет изменяться слева от 0 до 300px.  
Также, вместо ключевых слов from и to можно использовать, соответственно, 0% и 100%. Стоит отменить, что ключевые кадры не обязательно должны начинаться с 0% и заканчиваться 100%. Например @keyframes box {
																	50% {left: 0;}				
																	90% {left:300px;}	
Кроме animation-name включающего в себя @keyframes также существуют другие свойства анимации: 2)animation-duration (задает время в секундах/миллисекундах, сколько должен длиться один цикл анимации. По умолчанию значение равно 0s, это означает, что никакой анимации нет. Можно указать несколько значений перечисляя их через запятую. Также недопустимо указывать время без единиц измерения (s или ms)). 3)animation-timing-fuction (устанавливает, согласно какой функции должна происходить анимация каждого цикла между ключевыми кадрами. Самая распостраненная это linear, но могут быть и easy и steps и др.)4)animation-delay (устанавливает время ожидания перед запуском цикла анимации.5)animation-iteration-count (данное свойство определяет сколько раз проигрывать цикл анимации до её остановки. Этому свойству можно задать infinite и тогда анимация будет бесконечной) 5)animation-direction (устанавливает направление движения анимации со значениями: normal, alternate, reverse, alternate-reverse) 6)animation-fill-mode (определяет, какие стили должны применяться к элементу, когда анимация не проигрывается. Например, после её завершения или при остановке. На практики самой часто значение данного свойства это forward (animation-fill-mode:forwards(к элементу по окончанию анимации применяется стиль последнего ключего кадра))) 7)animation-play-state (свойство определяет, проигрывать анимацию или поставить её на паузу. Данное свойство имеет два значения: running и paused.)
В нашем же примере через @keyframe animation-name задано имя анимации - my-custom-name, а ниже последовательность её действий (ключевые кадры анимации):
при 50% анимации div c его содержимым отступает на 140px влево, потом на 80% анимации возрвращается назад на 50px от левого края и вконце делает отступ на 170px от края. Ниже, через hover, прописывается само свойство animation, где задается animation-duration т.е. длительность нашей анимации, а после animation-duration задается animation-name (my-custom-name), которое было использоване выше в @keyframes. 
												-->

<!-- Пример с анимацией -->						

<!-- <div>animate me!</div> -->

<!-- Еще один пример
В прошлом примере мы задавали все свойства анимации через animation. Здесь же мы задаем все свойства по отдельности. -->

<!-- <div>animate me!</div> -->

<!-- Пример с анимацией и transition
В этом примере мы использовали transition и animation. Вначале, через @keyframes мы задали имя анимации и её ключевые кадры (последовательность действий анимации), после этого задали div, в которой лежит наш контент, свойство transition (которое делают нашу анимацию плавной), в котором прописали вначале указали transition-property  (т.е то свойство, которое мы хотим "транзишить" т.е. над которым мы хотим осуществить плавный переход.), а после transition property мы указали transtion-duration. В данном примере будет происходить плавный переход от 0 до 100 px слева на право за 1.75s и наоборот с права на лево т.е. осуществляеться плавный переход над margin-left. Дальше, при чекнутом checkbox, с помощью родственного селектор "~" осуществится поиск всех div, которые имеют общий родитель с искателем (в нашем примере это input:checkbox) и применится к ним (в нашем случае это 1 div) animation, в ко	тором вначале идет длительность анимации, а потом её название, который выше было задано с помощью @keyframes. Также после задания animation задается margin-left:100px, к которому применится наш выше указанный transition. Т.е. при чекнутом сheckbox у нас будет применяться анимация и наш "animate me" будет находится на 100px от левого края. При не чекнутом checkbox наш "animate me"  перейдет в начало левого края т.к. в этом случае не будет margin-left и сделает это плавно т.к. на margin-left стоит transition.         -->

<!-- <input type="checkbox" id="a">
<label for="a">animate him!</label>
<div>animate me!</div> -->

<!-- Пример задания двух анимаций одновременно
В данном примере у нас две анимации: одна на перемещение (margin-left), а другая на цвет и прозрачность. И чтобы все переходы в анимации были плавными div прописано свойство transition в значении all, т.е. изменения состояния в этой анимации будет плавными.
Следует отметить, что часто animation/transition/transformation работают только с венторными префиксами. -->


<!-- <input type="checkbox" id="a">
<label for="a">animate him!</label>
<div>animate me!</div> -->

<!-- Пример с применением animation-play-state
Еще раз напомним, что animation-play-state это свойство, которое определяет, проигрывать анимацию или поставить её на паузу. При продолжении установленной на паузе анимации она начинается с того момента где была остановлена. Данное свойство существует в двух значениях: running(проигрывать анимацию) и paused(поставить анимацию на паузу). -->

<!-- <input type="checkbox" id="a">
<label for="a">animate him!</label>
<input type="checkbox" id="b">
<label for="b">pause him</label>
<div>animate me!</div> -->

<!-- Пример animation-fill-mode
Еще раз напомним, что animation-fill-mode это свойство, которое определяет какие стили должны применяться к элементу, когда анимация 	не проигрывается. Например, после её завершения или при остановке. Свойство animation-fill-mode позволяет сделать так, чтобы стиль элемента оставался как у последнего ключевого кадра. animation-fill-mode в значении 1)forward позволяет по окончанию анимации применить стиль ПОСЛЕДЕГО ключевого кадра т.е. застыть на последнем кадре, animation-fill-mode в значении 2)backwards позволяет к элементу применить стиль ПЕРВОГО ключевого кадра и он остаётся на протяжении периода заданного в animation-delay, т.е. застыть на последнем кадре, animation-fill-mode в значении 3)both применяет к элементу оба правила как forward так и backward. -->


<!-- <input type="checkbox" id="a">
<label for="a">animate him!</label>
<input type="checkbox" id="b">
<label for="b">stop at the end</label>
<div>animate me!</div> -->

<!-- Пример с 3d анимацией
В данном пример использовано одно из значений transform, а именно preserve 3d (transform: preserve 3d;).
Итак, в этом примере у нас 2 div с параметрами квадрата. .wow находится внутри .frame, которой заданы в свою очередь кроме прочих свойств transition в значении all, которое делает все переходы состояний трансформации не резкими, а плавными, ниже мы включаем поддержку 3d свойством transform-style: preserve-3d. Дальше при чекнутом чекбоксе блок .frame будет будет сделает поворот на 180 градусов вокрус оси У. Дальше в самом frame находится wow, который спозиционирован абсолютно посредине его родителя (.frame.) и которому в свою очередь тоже задана трансформация поворотом уже на 90 градусов, а также применен box-shadow.  -->

<!-- <input type="checkbox" id="a">
<label for="a">animate him!</label>
<div class="frame">
	<div class="wow"></div>
</div> -->

<!-- Следует заметить, что многие css свойства прописаны браузером по умолчанию (например margin между блоками или padding и margin в списках). Можно сбросить их вручную, но можно воспользоваться готовыми техниками: 	normalise.css или reset.css -->

</body>
</html>