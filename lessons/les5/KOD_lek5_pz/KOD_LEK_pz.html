<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>KOD_LK_pz</title>

<link rel="stylesheet" href="css/styles.css">

</head>в
<body>

<!-- Рекомендации при абсолютном позиционировании -->

<!-- Если задавать нулевые координаты (top:0, right:0, left:0, bottom:0), то
абсолютно спозиционированный блок будет растягиваться на всю ширину родительского в сторону соответствующих координат.
Также если мы поместим в блок абсолютно спозиционированную картинку, то мы
не сможем её растянуть задавая нулевые координаты ибо она имеет фиксированные размеры и тем самым является не заменяемым елементом, кроме того будет в приоритете left и top, то бишь она будет слева вверху. Также мы не сможем растянуть(посредствам абсолюта, задавая нулевые координаты сторонам) ЛЮБОЙ елемент(блок)с фиксированными размерами.
Также можно абсолютно спозиционированному блоку внутри родителя (с position:relative) задать margin:auto (cвойство auto означает, что объект будет расположен по средине той координаты какой задано auto, если же auto задано и для x и для y, то объект(блок) будет по середине всего блока, а не отдельной координаты (например x)) и всем координатам при этом (top/right/left/bottom) задать нулевые значения, то наш блок (абсолютно спозиционированный) будет по средине родителя, а если мы будем отключать соответсвующие координаты (например left=0;), то получим наш спозиционированный блок (в нашем примере position) по средине правой стенке нашего родительского блока или нижней (если отключим top:0). -->


<!-- <div class="parent">
	
<div class="position">	
	
<div class="position_inner"></div>

</div>

</div> -->



<!-- Свертсаем интересное задание применяя в основном absolute:fixed (popup) Данное задание есть типичным вариант для запрета копирования из сайта, а также установки банера(с рекламой) посреди страницы.-->


<div class="pagecontent">
<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Eaque necessitatibus laudantium, saepe iure, numquam enim deserunt doloribus sint id tempora? Aut est natus nihil non, eligendi repudiandae cum. Omnis, aliquid!Lorem ipsum dolor sit amet, consectetur adipisicing elit. Eaque necessitatibus laudantium, saepe iure, numquam enim deserunt doloribus sint id tempora? Aut est natus nihil non, eligendi repudiandae cum. Omnis, aliquid!Lorem ipsum dolor sit amet, consectetur adipisicing elit. Eaque necessitatibus laudantium, saepe iure, numquam enim deserunt doloribus sint id tempora? Aut est natus nihil non, eligendi repudiandae cum. Omnis, aliquid!Lorem ipsum dolor sit amet, consectetur adipisicing elit. Eaque necessitatibus laudantium, saepe iure, numquam enim deserunt doloribus sint id tempora? Aut est natus nihil non, eligendi repudiandae cum. Omnis, aliquid!Lorem ipsum dolor sit amet, consectetur adipisicing elit. Eaque necessitatibus laudantium, saepe iure, numquam enim deserunt doloribus sint id tempora? Aut est natus nihil non, eligendi repudiandae cum. Omnis, aliquid!Lorem ipsum dolor sit amet, consectetur adipisicing elit. Eaque necessitatibus laudantium, saepe iure, numquam enim deserunt doloribus sint id tempora? Aut est natus nihil non, eligendi repudiandae cum. Omnis, aliquid!Lorem ipsum dolor sit amet, consectetur adipisicing elit. Eaque necessitatibus laudantium, saepe iure, numquam enim deserunt doloribus sint id tempora? Aut est natus nihil non, eligendi repudiandae cum. Omnis, aliquid!Lorem ipsum dolor sit amet, consectetur adipisicing elit. Eaque necessitatibus laudantium, saepe iure, numquam enim deserunt doloribus sint id tempora? Aut est natus nihil non, eligendi repudiandae cum. Omnis, aliquid!Lorem ipsum dolor sit amet, consectetur adipisicing elit. Eaque necessitatibus laudantium, saepe iure, numquam enim deserunt doloribus sint id tempora? Aut est natus nihil non, eligendi repudiandae cum. Omnis, aliquid!Lorem ipsum dolor sit amet, consectetur adipisicing elit		. Eaque necessitatibus laudantium, saepe iure, numquam enim deserunt doloribus sint id tempora? Aut est natus nihil non, eligendi repudiandae cum. Omnis, aliquid!Lorem ipsum dolor sit amet, consectetur adipisicing elit. Eaque necessitatibus laudantium, saepe iure, numquam enim deserunt doloribus sint id tempora? Aut est natus nihil non, eligendi repudiandae cum. Omnis, aliquid!
</p>
</div>

<div class="paranja"></div>
<div class="window">
	<span class="close">x</span>
	<div class="content">Какой-то контент</div>
</div>


 													<!-- clip -->

<!-- <div class="clip">
	<img src="http://www.profi-forex.org/system/Pages/jandeksnovosti.jpg" alt="">
</div> 													 -->



													<!-- overflow -->
<!-- Итак, у свойства overflow(Свойство overflow управляет отображением содержания блочного элемента, если оно целиком не помещается и выходит за область заданных размеров.) существует 4 cвойства: visible (отображается
все содержимое элемента, даже если контент выходит за рамки блока),
hidden(все, что не влезает в блок - будет скрыта), auto (появляются скроллы, если контент вылазит за рамки блока), scroll (скролл появляется всегда)
Также, можно использоваться эти свойства по иксу и по игреку (overflow-x:hidden/overflow-y:auto)													 -->

<!-- <h2>visible</h2>													

<div class="block">
	
трололrwrwrw<br>
трололrwrwrwrw<br>
трололrwrwrwrw<br>	
трололrwrwrwrw<br>
трололrwrwrwrw<br>
трололrwrwrwrw<br>

</div> -->
<!-- Если нам нужно расположить картинки в строку, чтобы они при уменьшении 
ширины не вылазили из блока, а просто исчезали, нам нужно блоку, в 
котором находятся картинки задать свойство overflow:hidden, и тогда это 
свойство обрежет все выпадающие картинки, которые будут выпадать в другую
строку т.к. overflow:hidden обрезает все, что выходит за рамки блока, а поскольку img - строчный елемент, то если она перейдет на другую строку, то выйдет за рамки блока и данное свойство её обрежет. -->
<!-- Т.е. если у нас мало места, но много картинок, то мы можем показывать их по мере освобождения нашего места с помощью overflow:hidden. -->



<!--   <div class="overflow">
    <img src="http://lorempixel.com/100/100/" alt="">
    <img src="http://lorempixel.com/100/100/" alt="">
    <img src="http://lorempixel.com/100/100/" alt="">
    <img src="http://lorempixel.com/100/100/" alt="">
    <img src="http://lorempixel.com/100/100/" alt="">
    <img src="http://lorempixel.com/100/100/" alt ="">
    <img src="http://lorempixel.com/100/100/" alt="">
    <img src="http://lorempixel.com/100/100/" alt="">
  </div> -->

<!-- Тут мы видим, что при уменьшении ширины данный блок обрезается(благодаря свойству overflow:hidden, которое не позволяет чему-то вылезти за рамки блока и когда мы изменяем ширину, то соответственно меняется и ширина нашего блока в который уже не влазит текст из-за уменьшения ширины и тогда когда он вылазит, overflow:hidden обрезает его, а при задании свойства text-overflow:ellipsis блок также обрезается, но на месте обрезанных букв ставится три точки. --> 				


<!--   <div class="overflow-text">
    КакойтоДартаньянВыбралНикнеймБезПробелов<br>
    Хороший никнейм с пробелами и все такое
  </div> -->


																	<!-- Слои -->

<!-- У нас есть блок с шириной/высотой и бэграундом в котором есть картинка. Картинке через класс задано position:relative, что означает её позиционированние относительно блока в котором она находится. Дальше мы задаем ей свойство z-index: -1, которое заварачивает часть этой картинки под блок. Важно понимать, что свойство z-index применяется только к спозиционированным элементам. -->
<!-- Дальше нужно понимать, что когда мы допустим имеем блок с фоном в котором есть елементы тоже с фоном, то какое-бы значения z-index мы не поставили этим елементам мы не сможем перекрыть ими родитель, а также блок вне родителя, который допустим тоже имеет свой фон. Т.Е. елементы в родителе могут перекрывать только себя но не могут свеого родителя, а также другие блоки, которые не находится в ихнем родителе. Также если мы зададим родителю с елементами z-index больше чем у другого блока, то наш родитель перекроет этого другой блок ВМЕСТЕ со своими внутренними елементами т.к. приоритет всего слоя будет больше
 -->


<!-- <div class="layer"><img class="someimg" src="http://yandex.st/lego/_/X31pO5JJJKEifJ7sfvuf3mGeD_8.png" alt="">
</div> -->

<!-- С помощью слоев также можно делать каскадные конструкции. В нижнем примере мы создали блок (kaskad_index) с фиксированными размерами (widh:200px/height:200px),марджинами, паддингами, бордером применили к этому блоку position:relative. Эти же свойства мы применили и к after и к before этого блока (через запятную)и добавили абсолюты перебивая relative и тем самым создали такие же блоки перед нашим блоком (kaskad_index) и после нашего блока (kaskad_index) т.е. образовали некий каскад: вначале before(с дублированными цсс свойствами kaskad_index) потом обычный блок (kaskad_index), потом after(с дублированными цсс свойствами kaskad_index). Вообще псевдоклассы after и 	before делают изменения вначале и вконце елемента, но в нашем примере они работают каскадом. Добавив absolute и установив координаты смещения (top:... /left:...) относительно нашего блока kaskad_index(у которого прописано position:relative) наши before и after  теперь можно  различить т.к. их края видны и мы наблюдаем некий каскад из трёх страниц. Теперь с помощью z-index мы можем менять местами наши блоки:before/after/kaskad_index.   -->



<!-- <div class="kaskad_index">Страница</div> -->



										<!-- Таблицы -->
<!-- Основной особенностью таблицы является то, что из неё никогда не будет выперать никакой текст также из плюсов таблицы является то, что ячейки 1)ячейки не переносятся 2)не выпускают из себя контент (ячейки) 3)не разваливаются при различных разрешениях/ширинах. Раньше все верстка была табличной и большим плюсом этого было то, что каким бы образом не ресайзилось окно контент не вылезал из ячейки. При дивах этого нету, т.е. если мы пишем текст, а ширина нашего блока каким-то образом ограничена, то текст начнет вылазит, налазить на другие блоки. Но есть один существеннейший минус в верстке с помощью таблиц - бразуер не отображет содержимое таблицы, пока оно ПОЛНОСТЬЮ не загружено т.е. приходится ждать пока не загрузиться абсолютно вся таблица, кроме того бывает, что таблица находится в другой таблице, а та в другой таким образом работа сайта очень существенно замедляется. При дивах такой фигни нету, т.е. браузер загрузил первый див и сразу же его отобразил.
Таким образом, таблицы были очень распостранены раньше, в контексте табличной верстки, и большинство древних сайтов (на IE) написанны именно на табличной верстки, но на данный момент таблицы нужно использовать именно по назначению (таблица успеваемости ученоков), а не как некий метод оформления ВСЕГО сайта, к тому же сейчас можно верстать таблицу с помощью дивов просто задавая им через дисплей нужные свойства.
Также можно указать основные способы сделать так, чтобы из дивово не вылазил текст:1)overflow:hidden также добавить text-overflow: ellipsis для троеточия
      2)overflow:scroll или auto (будет появляться скролл внутри дива)
      3)Если мы хотим, чтобы наш див рисайзился (менял размеры) по мере контента можно применять к нему свойство display: inline-block, тогда у него будет граница и он будет расширяться по контенту.-->




<!-- thead/tfoot/tbody в принципе не обязательно писать, но а)так семантично б)поисквые системы быстрее обратят внимание на твою таблицу.
<!-- Также нужно помнить, что по-правилам нужно вначале прописывать thead и tfoot,а уже потом tbody. Тег col означает колонку и прописывается для того, чтобы потом в цсс можно было бы обратившись к нему задать какие-то свойства колонке, colgroup оборачивает колы. > -->


	<!-- <table>

		<caption>Table Caption</caption>
		
<colgroup>
<col>
<col>
</colgroup>


<thead>
	<tr>
		<th>table head col 1</th>
		<th>table head col 2</th>
	</tr>
</thead>

<tfoot>
	<tr>
		<td>table cell 1</td>
		<td>table cell 2</td>
	</tr>
</tfoot>

<tbody>
	<tr>
		<td>table foot cell 1</td>
		<td>table foot cell 2</td>
	</tr>
</tbody>

	</table> -->

<!-- Та же самая таблица, только верстаем её с помощью дивов преобразовую с помощью следующих команд соответствующие блоки: display:table (перевод обычного блока в таблицу), display: table-caption (перевод обычного блока в заголовок), display:table-header-group(перевод обычного блока в табличный елемент thead) display:table-row-group(перевод обычного блока в табличный елемент tbody) display:table-footer-group(перевод обычного блока в табличный елемент thead) display:table-row (перевод обычного блока в табличный елемент tr) display:table-cell(перевод обычного блока в табличный елемент th,td)-->


<!-- <div class="table">
	
 <div class="caption">table caption</div>

 <div class="thead">

  <div class="tr">
	  <div class="th">table head col 1</div>
	  <div class="th">table head col 1</div>
  </div>

</div>

<div class="tbody">

  <div class="tr">
	  <div class="td">table cell 1</div>
	  <div class="td">table cell 2</div>
  </div>
</div>

	
<div class="tfoot">
	
	<div class="tr">
		 <div class="td">table foot cell 1</div>
		 <div class="td">table foot cell 2</div>
	</div>
</div>

</div> -->

														<!-- table-layout -->

<!-- применяя table-layout: auto ячейка таблицы расширяется по-контенту т.е. чем больше контента - тем больше ячейка, это свойство стоит по-умолчанию в таблицах, а вот если мы пропишем table-layout: fixed делает размер ячейки таблицы фиксированным и тогда уже при увеличении контента в ячейке он будет просто вылазить за её рамки. 
В нашем примере к первом таблице применено свойство table-layout:fixed и при уменшьшении страницы по средствам резиновой верстки контент вылазит за рамки ячейки, а во второй таблице все стоит по умолчанию т.е. table-layout:										 -->

<!-- <table class="t1">
  <tr>
    <td>длинноеСловоВПервойСтроке</td>
    <td>вторая строка</td>
  </tr>	
  <tr>
    <td>Вторая строка - 1</td>
    <td>Вторая строка - 2</td>
  </tr>	
</table>
<br/>

<table class="t2">
  <tr>
    <td>длинноеСловоВПервойСтроке</td>
    <td>вторая строка</td>
  </tr>	
  <tr>
    <td>Вторая строка - 1</td>
    <td>Вторая строка - 2</td>
  </tr>	
</table> -->

														<!-- Прятки -->


<!-- Существует два способа скрыть елемент: 1) visibility:hidden (скрывает елемент, но оставляет место которое он занимал) 2)display: none (полностью уберает елемент вместе с его местом, которое он занимал) -->

<ul>
  <li>1</li>
  <li>2</li>
  <li class="choosen">3</li>
  <li>4</li>
  <li>5</li>
</ul>
</body>
</html>