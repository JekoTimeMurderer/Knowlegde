
																														//Введение в методы и свойства

// Свойство length показывает длину

alert('Привет, мир!'.length); // способ 1

var str = 'Привет, мир!'; // способ 2
alert(str.length);

//Метод toUpperCase() возвращает строку в верхнем регистре

var hello = 'Привет, мир!';
alert(hello.toUpperCase());

//Метод для чисел toFixed(n). Даний метод округляет число "num" до n знаков после запятой, а при необходимости
//добивает нулями до данной длины и возвращает в виде строки.

Способ 1:
var n = 12.345;

alert(n.toFixed(2)); // "12.35" 
alert(n.toFixed(0)); // "12"
alert(n.toFixed(5)); // "12.34500"

Способ 2:
alert(12.34.toFixed(1)); // 12.3
Если будет целое число, то нужно использовать две точки т.к. Javascript ожидает десятичную дробь после точки.
alert(12..toFixed(1)); // 12.0

																																						//Числа
//NaN(Not-a-Number)

- Значение NaN можно проверить специальной функцией isNaN(n), которая преобразует аргумент к числу и возвращает
true, если получилось NaN, и false - для любого другого значения.
Пример:
var n = 0/0;

alert(isNaN(n)); // true 
alert(isNaN('12')); // false, строка преобразовалась к обычному числу 12
При этом, если аргумент isNaN не число, то он автоматически преобразуется к числу.

- Значение NaN прилипчиво. Любая операция с NaN возвращает NaN.

alert(NaN + 1); // NaN

- isNaN(str) можно использовать для проверки строки на число. Эта функция подобно + проеобразует строку в число.
+Однако здесь нужно быть осторожным со значениями: пустая строка/строка из пробельных символов преобразуются в 0 и это будет false.
+isNaN посчитает числами значения false/true/null, так как хотя это не число, но isNaN преобразуеет их к числам и выдаст false.


//isFinite(n)

Обычно если мы хотим от посетителя получить число, то Infinity или NaN нам не подходят.
Для того, чтобы отличить обычные числа от таких специальных значений существует функция isFinite.

Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не NaN/Infinity/-Infinity: 
Пример:
alert(isFinite(1)); // true
alert(isFinite(Infinity)) // false
alert(isFinite(NaN)); // false

//Преобразование к числу
Явно это делает унарный плюс, при этом, если строка не является в точности числом, то результат будет NaN:
Пример:
alert(+"12test"); //NaN

Единственное исключение - пробельные символы в начале и в конце строки, которые игнорируются

alert(+'  -12'); // -12
alert(+"\n34  \n") // 34, перевод строки \n является пробельным символом
alert(+""); // 0, пустая строка становится нулем
alert(+'1 2'); //NaN, пробел посредине числа - ошибка


//parseInt и parseFloat(эти функции делают числа из строк, которые начинаются с числа)
Функция parseInt и ее аналог ParseFloat преобразуют строку символ за символом, пока это возможно.
При возникновении ошибки возвращается число, которое получилось. 
Функция parseInt читает из строки целое число, а parseFloat - дробное.
Пример:
alert(parseInt('12px')) // 12, произойдет ошибка на символе 'p'
alert(parseFloat('12.3.4')) // 12.3, произойдет ошибка на второй точке

Функции parseInt и parseFloat возвращают NaN при ошибке на первом символе:
alert(parseInt('a123')); //NaN
Функция parseInt также позволяет указать систему счисления, т.е. считывать числа, заданные в шестнадцатиричной
и других системах счисления.

//isNumeric
function isNumeric(n) {
	return !isNaN(parseFloat(n)) && isFinite(n);
}
Принцип работы:
+Функция isFinite(n) преобразует аргумент к числу и возвращает true, если это не Infinity/-Infinity/NaN.
Таким образом правая часть отсеет заведомо не-числа, но оставит такие значения как true/false/null и пустую строку ''.
+Для их проверки(true/false/null) нужна левая часть. Вызов parseFloat(true/false/null/'') вернет NaN для этих значений.
Так устроена функция parseFloat: она преобразует аргумент к строке, т.е. true/false/null становятся 'true'/'false'/'null', а затем
считывает из неё число, при этом пустая строка дает NaN. В результате отсеивается все, кроме строк-чисел и обычных чисел.

//toString(основание системы)
С помощью данного метода можно получить 16-ричное представление числа. 
Пример:
var n = 255;

alert(n.toString(16));

Основание может быть от 2 до 36.

//Округление 
math.floor // округляет вниз
math.ceil // округляет вверх
math.round // округляет до ближайшего целого

Пример:
alert(Math.floor(3.1)); // 3
alert(Math.ceil(3.1)); // 4
alert(Math.round(3.1)); // 3
Для округления до нужного знака нужно использовать +n.toFixed(p), где p - precision т.е. точность.

//Округление до заданной точности c помощью метода .toFixed(precision), который возвращает результат в виде строки:
Пример:
var n = 12.34;
alert(n.toFixed(1)); // "12.3"
Округление идет до ближайшего значения, аналогично Math.round, но при этом Math.round работает корректней:
Пример:
var n = 12.36;
alert(n.toFixed(1)); //"12.4"

//Неточные вычисления(дробные числа дают ошибку вычислений)
Эти вычисления происходят из-за стандарта IEEE 754 и десятичные дроби вроде 0.1 или 0.2 в двоичной системе является бесконечными
дробями. Двоичное значение бесконечных дробей хранится только до определенного знака, поэтому возникает неточность.Её можно увидеться 
если посмотреть на Пример:
Пример:
alert(0.1.toFixed(20)); //0.1000000000000000000555
Т.е. когда мы например складываем две таких бесконечных дроби(0.1+0.2), то получаем одну неточность.
Избавиться от этого можно так 1):
alert(0.1 * 10 + 0.2 * 10) / 10); //0.3
Или так: сложить, а потом округлить до разумного знака после запятой. Округление до 10-го знака обычно достаточное.
var result = 0.1 + 0.2;
alert(+result.toFixed(10)); // 0.3

//Другие математические методы
Math.sqrt(x) // возвращает квадратный корень из х
Math.pow(x, exp) // Возводит число в степень, возвращает x в степени exp. Например Math.pow(2,3) = 8
//Работает в том числе с дробными и отрицательными степенями, например Math.pow(4, -1/2) = 0.5
Math.random() // возвращает псевдослучайного число в интервале [0.1) - между 0 и 1(не включая)

//Форматирование
Для красивого вывода чисел в стандарте ECMA 402 есть метод toLocaleString():
Пример:
var number = 123456789;
alert(number.toLocaleString());
Он также умеет форматировать валюту и проценты.

																																		//СТРОКИ
//Специальные символы + экранация:
\n - перевод строки
Специальные символы нуждаются в экранации. Чтобы экранировать символ нужно вначале приписать обратный слэш \.
Пример:
alert('I\'m javascript \'programmer\''); // I'm javascript 'programmer'
alert("I'm javascript \"programmer\""); // I'm javascript "programmer"
В памяти строка будет содержать символ без обратного слэша \ , а сам символ обратного слэша \ является служебным и
потому сам всегда экранируется т.е. пишется как \\
Вообще экранировать можно любой символ. Если он не специальный, то ничего не произойдет.

//Доступ к символам.
1)Чтобы получить символ, используйте вызов charAt(позиция). Первый символ имеет позицию 0:
Пример:
var str = "jQuery";
alert(str.charAt(0)) // 'j'
В Javascript нет отдельного типа "символ", так что charAt возвращает строку, состоящую из выбранного символа.
2)Также для доступа к символу можно использовать квадратные скобки:
Пример:
var str = "Я - современный браузер!";
alert(str[0]); // "Я"

Разница между этим способом и charAt заключается в том, что если символа нет - charAt выдает пустую строку, а скобки - undefined:
Пример:
alert("".charAt(0)); // пустая строка
alert(""[0]); // undefined
Вообще метод со скобками проще и короче.

//Изменение строк
Содержимое строки в Javascript нельзя изменять. Т.е. нельзя взять символ посередине и заменить его. 
Как только строка создана - она такая навсегда.
Можно лишь создать целиком новую строкуи присвоить в переменную вместо старой.
Пример:
var str = "строка";
str = str[3] + str[4] + str[5];
alert(str); //ока

//Смена регистра
Методы toLowerCase() и toUpperCase() меняют регистр строки на нижний/верхний:
Пример:
alert("Интерфейс".toUpperCase()); // ИНТЕРФЕЙС
Пример ниже получает первый символ и приводит его к нижнему регистру:
alert("Интерфейс"[0].toLowerCase()); // 'и'

//Поиск подстроки 
Для поиска подстроки(скорее буквы) есть метод indexOf(подстрока[,начальная_позиция]).
Он возвращает позицию, на которой находится подстрока(точнее буква) или -1, если ничего не найдено.
Пример:
var str = "Widget with id";

alert(str.indexOf("Widget")); //0, т.к. "Widget" найден прямо в начале str
alert(str.indexOf("id")); // 1, т.к. найден, начиная с позиции 1
alert(str.indexOf("widget")); // -1, не найдено, так как поиск учитывает регистр
Необязательный второй аргумент позволяет искать начиная с указанной позиции.
Например, первый раз 'id'(а точнее буква i) появляется на позиции 1. Чтобы найти его следующее появление - запустим поиск с позиции 2:
Пример:
var str = "Widget with id";
alert(str.indexOf("id", 2)) // 12, поиск начат с позиции 2
Также существует аналогичный метод lastIndexOf, который ищет не сначала, а с конца строки.
Также нужно запомнить '~' читается как "не минус один", "if(~str.indexOf)" читается как "если найдено".
Знак ~ применяется для красивого вызова indexOf.

//Взятие подстроки:substr,substring,slice
Метод substring(start[,end]) возвращает подстроку(букву) от позиции start включительно до позиции end не включительно
Пример:
var str = "stringify";
alert(str.substring(0,1)); // "s", т.е. символ от позиции start(0) включительно до позицци end(1) не включительно
Если аргумент end отсутствует, то идет до конца строки
Пример:
var str = "stringify";
alert(str.substring(2)); //ringify, символы с позиции 2 до конца

Метод substr(start[, length])
Первый аргумент имеет такой же смысл как и substring, а второй содержит не конечную позицию, а количество символов

																																			//Объекты 
Пустой объект(пустой шкаф) может быть создан двумя синтаксисами:
1. o = new Object();
2. o = {}; // пустые фигурные скобки
Пример:
var person = {}; // пока пустой

Второй синтаксис более оптимальный.
Основные операции с объектами - это создание, получение и удаление свойств.
Объект может содержать в себе любые значения, которые называются свойствами объекта. Доступ к свойствам осуществляется по имени свойства,
иногда говорят "по ключу". Для обращение к свойствам используется запись "через точку", вида объект.свойство
Пример:
person.name = 'Вася'
person.age = 25;
При присвоении свойства в объекте(в шкафу) автоматически создается "ящик" с именем "name" и в него записывается значение'Вася'. Значения
могут быть любых типов: число, строка - не важно.
Для того, чтобы считать эти значения - также обратимся через точку:
alert(person.name + ': ' + person.age); //"Вася: 25"
- Удаление осуществляется оператором delete: 
Пример:
delete person.age;

- Иногда бывает нужно проверить есть ли в объекте свойство с определенным ключом.Это можно сделать двумя способами: in и undefined
1.Для этого есть особый оператор: "in". Его синтаксис: "prop" in obj. Причем имя свойства - в виде строки
Пример:
if("name" in person){
	alert("Свойство name существует!");
}
Чаще используется другой способ - сравнение значения с undefined.
Важное правило: в Javascript можно обратится к любому свойству объекта даже если его нет.
2.Но если свойство не существует, то вернется специальное значение undefined:
Пример:
var person = {};
alert(person.lalala); //undefined, т.к. нет свойства с ключом lalala
Таким образом мы можем легко проверить существование свойства - получив его и сравнив с undefined:
Пример:
var person = {
	name: "Василий"
};

alert(person.lalala === undefined); // true, свойства нет
alert(person.name === undefined); // false, свойство есть

//Доступ через квадратные скобки
Существует альтернативный синтаксис работы со свойствами, использующий квадратные скобки объект['свойство']:
Пример:
var person ={};
person['name'] = 'Вася'; // То же, что и person.name = 'Вася'
Записи person['name'] и person.name идентичны, но квадратные скобки позволяют использовать в качестве свойства любую строку
Пример:
var person{};
person['Любимый стиль музыки'] = 'Джаз';
Такое присвоение было бы невозможно "через точку", потому что интерпретатор после первого пробела подумает, что свойство закончилось
и далее выдаст ошибку...
Пример:
var person = {};
person.любимый стиль музыки = 'Джаз'; // ??? ошибка
НО в обоих случаях, ИМЯ СВОЙСТВА ОБЯЗАНО БЫТЬ СТРОКОЙ. Если использовано значение другого типа - javascript приведет его к строке автоматом.

//Доступ к свойству через переменную
Квадратные скобки также позволяют обратится к свойству, имя которого хранится в переменной. 
При чем это единственный способ как можно обратися к свойству если оно находится в переменной.
Пример:
var person = {};
person.age = 25;
var key = 'age';

alert(person[key]) // то же самое, что person['age']

//Объявление со свойствами
Объект можно заполнить при создании, указав в фигурных скобках: {ключ1: значение 1, ключ 2: значение 2, ...}. Такой синтаксис наз. литеральным																																		
Следующие два фрагмента кода создают одинаковый объект:
var menuSetup = {
	width: 300,
	height: 200,
	title: 'Menu'
};
И это то же самое что:
var menuSetup = {};
menuSetup.width = 300;
menuSetup.height = 200;
menuSetup.title = 'Menu';
Название свойств можно перечислять как в кавычках, так и без:
var menuSetup = {
	width: 300,
	'height': 200,
	"мама мыла раму": true
};
Также в качестве значения свойства можно указать и другой объект
Пример:
var user = {
	name: "Таня",
	'age': 25,
	size: {
		top: 90,
		"middle": 60,
		bottom: 90
	}
}
alert(user.name); // Таня
alert(user.size.top); // 90
Здесь значение свойства size является объект {top: 90, middle: 60, bottom: 90}.

																															//Объекты,перебор свойств
Для перебора всех свойств из объекта используется цикл по свойствам for..in. Эта синтаксическая конструкция отличается от рассмотренного ранее
цикла for(;;)																															.
Пример:
for (key in obj){
// делать что-то с obj[key]
}
При этом for..in последовательно переберет свойства объекта obj, имя каждого свойства будет записано в key и вызвано тело цикла.
Вспомогательную переменную key можно объявить прямо в цикле:
for (var key in menu){
	//...
}
Также можно использовать любое другое название, кроме key.
Пример итерации по свойствам:
var menu = {
	width: 300,
	height = 200,
	title: "Menu"
};

for (var key in menu){
	alert('Ключ:' + key + "значение: " + menu[key]);
	// этот код будет вызван для каждого свойства объекта
	// ..и выведет имя свойства и его значение
}

//Количество свойств в объекте
Т.к. Готового метода не существует самый кросс-браузерный способ - это сделать цикл по свойствам и посчитать, вот так:

var menu = {
	width: 300,
	height: 200,
	title: "Menu" 
};

var counter = 0;

for(var key in menu) {
	counter++;
}
alert("Всего свойств: " + counter);

//Порядок перебора свойств
Если имя свойства - нечисловая строка, то такие ключи всегда перебираются в том же порядке, в каком присваивались.
Если же имя свойства - число или числовая строка, то такие свойства браузер сортирует с целью оптимизации
Пример:
var user = {
	name: "Вася",
	surname: "Петров"
};
user.age = 25;
//Т.к. имя свойства нечисловая строка, то свойства будут перебираться по порядку присвоения
for (var prop in user) {
	alert(prop); //name, surname, age
}

Пример с числами-свойствами:
var codes = {
	"7": "Россия",
	"38": "Украина",
	"1": "США"
};
for (var code in codes) alert(code); //1, 7, 38 т.е. видим, что не попорядку ибо ключи численные.
Для того, чтобы порядок был именно таким, каким нам нужно можно добавить какой-нибудь строчный знак, например знак "+"
а потом вконце добавить плюс для преобразование опять в число.

																											//Объекты - передача по ссылке
Фундаментальным отличием объектов от примитивов является их хранение и копирование "по ссылке".

Дело в том, что строки, булевы значения, null/undefined при присваивании переменных копируются целиком.
С объектами все не так.
В переменной, которой присвоен объект, хранится не сам объект, а "адрес его места в памяти", иными словами - "ссылка" на него.
Т.е. объект - вне переменной. В переменной  - лишь "адрес" для него.
Т.е при копировании переменной с объектом - копируется эта ссылка, а объект по-прежнему остается в единственном экземпляре.
Пример:
var user = {name: "Вася"}; // в переменной - ссылка
var admin = user; // скопировали ссылку
Т.е. мы получили две переменные, в которых находятся ссылки на один и тот же объект и нужно понимать т.к. объект всего один, то изменение 
через любую переменную видны в других переменных
Пример:
var user = { name: 'Вася' };
var admin = user;

admin.name = 'Петя'; // поменяли имя в объекте через admin
admin(user.name); // 'Петя', изменения видны в user
//Клонирование объектов
Иногда, на практике - очень редко, нужно скопировать объект целиком, создать именно полную независимую копию, "клон" объекта.
Пример:
var user = {
	name: "Вася",
	age: 30
}

var clone ={}; // новый пустой объект

// скопируем в него все свойства user
for (var key in user) {
	clone[key] = user[key];
}

//теперь clone - полностью независимая копия
clone.name = 'Петя' // поменяли данные в clone

alert(user.name); // по-прежнему "Вася"

Важное правило: При раскрытии свойств объекта в консоли - браузер всегда выводит их текущие значения.

																										//Массивы с числовыми индексами
Массив - разновидность объекта, которая предназначена для хранения пронумерованных значений и предлагает дополнительные 
методы для удобного манипулирования такой коллекцией.
Они обычно используются для хранения упорядоченных коллекций данных, например - списка товаров на странице, студентов в группе и т.п.

//Объявление
Синтаксис для создания нового массива - квадратные скобки со списком элементов внутри
Пример:
var arr = [];
Или:
var fruits = ["Яблоко", "Апельсин", "Слива"];
Элементы нумеруются, начиная с нуля.
Чтобы получить нужный элемент из массива - указывается его номер в квадратных скобках
Пример:
var fruits = ["Яблоко", "Апельсин", "Слива"];

alert(fruits[0]); // Яблоко
alert(fruits[1]); // Апельсин
alert(fruits[2]); // Слива

Элемент можно всегда заменить:
Пример:
fruits[2] = 'Груша'; // теперь ["Яблоко", "Апельсин", "Груша"]
Или элемент можно добавить
Пример:
fruits[3] = 'Лимон'; // теперь ["Яблоко", "Апельсин", "Груша", "Лимон"]

Общее число элементов, хранимых в массиве, содержится в его length:

Пример:
var fruits = ["Яблоко", "Апельсин", "Груша"];
alert(fruits.length); // 3

Через alert можно вывести и массив целиком.
При этом его элементы будут перечислены через запятую
Пример:
var fruits = ["Яблоко", "Апельсин", "Груша"];
alert(fruits); // Яблоко, Апельсин, Груша

В массиве может храниться любое число элементов любого типа
Пример:
var arr = [1, 'Имя', {name:'Петя'}, true];
//получаем объект из массива и тут же -- его свойство
alert(arr[2].name); // Петя

//Методы pop/push, shift/unshift
Методы для работы с концом массива:

pop удаляет последний элемент из массива и возвращает его
Пример:
var fruits = ["Яблоко", "Апельсин", "Груша"];

alert(fruits.pop()); // удалили "Груша" 
alert(fruits); // и соответственно возвратим массив без "Груша"

push добаляет элемент в конец массива
Пример:
var fruits = ["Яблоко", "Апельсин"];
fruits.push("Груша"); // добавляем элемент в конец массива
alert(fruits) // Яблоко, Апельсин, Груша

Методы работы для начала массива:

shift удаляет из массива первый элемент и возвращает его
Пример:
var fruits = ["Яблоко", "Апельсин", "Груша"];
alert(fruits.shift()); // удалил "Яблоко"
alert(fruits); // Апельсин, Груша

unshift добавляет элемент вначало массива
Пример:
var fruits = ["Апельсин", "Груша"];
fruits.unshift('Яблоко');
alert(fruits); // Яблоко, Апельсин, Груша

Методы push и unshift могут добалять сразу по несколько элементов
Пример:
var fruits = ["Яблоко"];

fruits.push("Апельсин", "Персик");
fruits.unshift("Ананас", "Лимон");

alert(fruits); // ["Ананас", "Лимон", "Яблоко", "Апельсин", "Персик"]

//Внутреннее устройство массива
Массив - это объект, где в качестве ключей выбраны цифры, с дополнительными методами и свойством length.
Важное правило: можно присваивать в массив любые свойства
Пример:
var fruits = []; //создаем массив
fruits[99999] = 5; //присвоить свойство с любым номером
fruits.age = 25; //назначить свойство со строковым именем
НО, вообще массивы для того и придуманы, чтобы удобно работать именно с упорядоченными, нумерованными данными.

//Вывод массива с "дырами"
Если в массиве есть пропущенные индексы, то при выводе в большинстве браузеров появляются "лишние" запятые
Пример:
var a = [];
a[0] = 0;
a[5] = 5;

alert(a); // 0,,,,,5
Эти запятые появляются потому, что алгоритм вывода массива идет от 0 до arr.length и выводит все через запятую. Отсутствие значений
дает несколько запятых подряд

//Влияние на быстродействие
Методы push/pop выполняются быстро, а shift/unshift - медленно.

//Перебор элементов
Для перебора элементов обычно используется цикл
Пример:
var arr = ["Яблоко", "Апельсин", "Груша"];

for (var i=0; i<arr.length; i++) {
	alert(arr[i]);
}

//Особенности работы length
Длина length - не количество элементов массива, а последний индекс +1 (т.к. отчет начинается с нуля)
Пример:
var arr = [];
arr[1000] = true;

alert(arr.length); //1001
Кстати, если у вас элементы массива нумеруются случайно или с большими пропусками, то стоит подумать о том, чтобы
использовать обычный объект. Массивы предназначены именно для работы с непрерывной упорядоченной коллекцией элементов.

//Используем length для укорачивания массива
Важное правило: при уменьшении length массив укорачивается.
При чем этот процес необратимый, т.е. даже если потом вернуть length обратно - значения не восстановятся
Пример:
var arr = [1, 2, 3, 4, 5];

arr.length = 2; //укоротить до 2 элементов
alert(arr); // [1,2]

arr.length = 5; // пытаемся вернуть length обратно, как было
alert(arr[3]); // undefined: значения не вернулись
Самый простой способ очистить массив - это arr.length=0

// Альтернативный способ создания массивов
Cуществует еще один один синтаксис для создания массива:
var arr = new Array("Яблоко", "Груша", "и т.п.");
Если у него один аргумент-число new Array(число), то он создает массив без элементов, но с заданной длиной
Пример:
var arr = new Array(2,3);
alert(arr[0]); // 2, создан массив [2, 3], все ок

arr = new Array(2); //создаст массив [2]
alert(arr[0]); // undefined! у нас массив без элементов, длины 2
Т.е. такой массив соответстует объекту {length: 2}

//Многомерные массивы
Массивы в Javascript могут содержать в качестве элементов другие массивы. Это можно использовать для создания многомерных массивов, матриц
var matrix = [
[1,2,3],
[4,5,6],
[7,8,9],
];

alert(matrix[1][1]); //центральный элемент

//Работа массива
Для эффективной работы с массивом нужно знать об следущих правилах:
1.Не ставить массиву произвольные свойства, такие как arr.test = 5. То есть, работать именно как с массивом, а не как с объектом.
2.Заполнять массив непрерывно и по возрастающей. Как только браузер встречает необычное поведение массива, например устанавливается 
значение arr[0], а потом сразу arr[1000], то он начинает работать с ним, как с обычным объектом. 
Как правило, это влечёт преобразование его в хэш-таблицу.
Т.Е.Если следовать этим принципам, то массивы будут занимать меньше памяти и быстрее работать.
 
																																		//МАССИВЫ МЕТОДЫ

//Метод split
Метод split(s) позволяет превратить строку в массив, разбив ее по раздилителю.
В разделителем является строка из запятой и пробела.
Пример:
var names = 'Маша, Петя, Марина, Василий';

var arr = names.split(', ');
for (var i=0; i<arr.length; i++){
	alert('Вам сообщения' + arr[i]);
}
У метода split есть необязательный второй аргумент - ограничение на количество элементов в массиве.
Если их больше, чем указано - остаток массива будет отброшен
Пример:
alert("a,b,c,d".split(',', 2)); //a,b
Вызов split с пустой строкой разобьет по буквам
Пример:
var str = 'тест';
alert(str.split('')); //т,е,с,т

//метод join
Метод join(str) делает в точности противоположное split. Он берет массив и склеивает его в строку используя str как разделитель.
Пример:
var arr = ['Маша', 'Петя', 'Марина', 'Василий'];
var str = arr.join(';');
alert(str); // Маша;Петя;Марина;Василий

new Array + join = Повторение строки
Код для повторения строки 3 раза:
alert(new Array(4).join("ля")); //ляляля
Как видно, new Array(4) делает массив без элементов длины 4, который метод join объеденяет в строку, вставляя между его элементами
строку "ля". В результате получается повторение строки.

//Удаление из массива
Так как массивы являются объектами, то для удаления ключа можно воспользоваться обычным delete
Пример:
var arr = ["Я", "иду", "домой"];

delete arr[1]; //значение с индексом 1 удалено

//теперь arr = ["Я", undefined, "домой"];
alert(arr[1]); //undefined
Нужно понимать, что оператор delete удаляя пару "ключ-значение" оставляет дырку, но нам обычно нужно, чтобы при удалении 
элементы сдвинулись и заполнили образовашиеся дыры.
Поэтому для удаления используются специальные методы: из начала - shift, с конца - pop, а с середины splice.

//Метод splice
Данный метод умеет все: удалять элементы, вставлять элементы, заменять элементы - по очереди и одновременно.
Пример удаления:
var arr = ["Я", "изучаю", "Javascript"];
arr.splice(1,1); // начиная с позиции 1, удалить 1 элемент
alert(arr); //осталось ["Я", "Javascript"]

В примере ниже мы удалим 3 элемента и вставим другие на их место:
var arr = ["Я", "сейчас", "изучаю", "javascript"];
//удалить 3 первый элемента и добавить другие вместо них
arr.splice(0, 3, "Мы", "изучаем")
alert(arr) // теперь ["Мы", "изучаем", "Javascript"]

В примере ниже видно, что splice возвращает массив из удаленных элементов:
var arr = ["Я", "сейчас", "изучаю", "Javascript"];
//удалить 2 первых элемента
var removed = arr.splice(0,2);
alert(removed); // "Я", "сейчас"

Метод splice также может вставлять элементы без удаления, для нужно лишь установить deleteCount в 0:
var arr = ["Я", "изучаю", "Javascript"];
//с позиции 2
//удалить 0
//вставить "сложный", "язык"
arr.splice(2, 0, "сложный", "язык");
alert(arr); // "Я", "изучаю", "сложный", "язык", "Javascript"
Также допускается использование отрицательного номера позиции, которая в этом случае отсчитывается с конца:
var arr = [1, 2, 5]
//начиная с позиции индексом -1(т.е.перед последним элементов)
//удалить 0 элементов
//затем вставить числа 3 и 4
arr.splice(-1, 0, 3, 4);
alert(arr); // результат: 1,2,3,4,5

//Метод slice
Метод slice (begin, end) копирует участок массива от begin до end, не включая end. Исходный массив при этом не меняется
Пример:
var arr = ["Почему", "надо", "учить", "Javascript"];
var arr2 = arr.slice(1, 3); // элементы 1, 2(не включая 3)
alert(arr2); // надо, учить

Если не указывать end - копирование будет до конца массива:
Пример:
var arr = ["Почему", "надо", "учить", "Javascript"];
alert(arr.slice(1)); //взять все елементы, начиная с номера 1	

Можно использовать отрицательные индексы, они отсчитываются с конца:
var arr2 = arr.slice(-2) // копировать от 2-го элемента с конца и дальше

Если вообще не указывать аргументов - скопируется весь массив:
var fullCopy = arr.slice();
Вообще синтаксис slice одинаков для строк и для массивов. 

//Сортировка, метод sort(fn)
Метод sort() сортирует массив на месте.
Пример:
var arr = [1, 2, 15];
arr.sort();
alert(arr); //1, 15, 2
Сортировка такая потому, что по умолчанию sort сортирует, преобразуя элементы к строке.
В примере выше сортировка такая т.к. "2" > "15".
//Свой порядок сортировки
Для указания своего порядка сортировки в метод arr.sort(fn) нужно передать функцию fn от двух элементов, которая умеет сравнить их.
Внутренний алгоритм функции сортировки умеет сортировать любые массивы, но для этого ему нужно знать, как их сравнивать. Эту роль выполняет fn
Если же эту функцию не указать, то элементы сортируются как строки.	
В методе sort, внутри самого интерпретатора Javascript, реализован универсальный алгоритм сортировки. Он решает, какие пары элементов и когда
сравнивать, чтобы отсортировать побыстрее. Мы даем ему функцию - способ сравнения.

//reverse
Метод arr.reverse() меняет порядок элементов в массиве на обратный.
Пример:
var arr = [1, 2, 3];
arr.reverse();

alert(arr); //3, 2, 1

//concat 
Метод arr.concat(value1,value2,...valueN) создает новый массив, в который копируется элементы из arr, а также value1, value2,... valueN.
Пример:
var arr = [1, 2];
var newArr = arr.concat(3,4);
alert(newArr); // 1,2,3,4

Если аргумент concat - массив, то concat добавляет элементы из него.
Пример:
var arr = [1,2];
var newArr = arr.concat([3,4], 5); //то же самое, что arr.concat(3,4,5)
alert(newArr); // 1,2,3,4,5

//indexOf/lastIndexOf
Метод "arr.indexOf(searchElement[,fromIndex]" возвращает номер элемента searchElement в массиве arr или -1, если его нет.
Поиск начинается с номера fromIndex, если он указан. Если нет - с начала массива. Для поиска используется строгое сравнение ===.
Пример:
var arr = [1, 0, false];

alert(arr.indexOf(0)); //1
alert(arr.indexOf(false)); //2
alert(arr.indexOf(null)); // -1 
Данный indexOf по синтаксису полностью аналогичен методу indexOf для строк.
Метод arr.lastIndexOf(searchElement,[,fromIndex]) ищет справа-налево: с конца массива или номера fromIndex, если он указан.
Методы indexOf/lastIndexOf осущестляют поиск перебором. Внутренняя реализация indexOf/lastIndexOf осуществляет полный перебор аналогично
циклу "for" по массиву.


// Object.keys(obj)
Свойства объекта можно перебрать в цикле for..in
Если мы хотим работать с ними в виде массива, то к нашим услугам метод Object.keys(obj) 
Пример:
var user = {
	name: "Петя",
	age: 30
}

var keys = Oject.keys(user);
alert(keys); //name, age
Т.е. Object.keys(arr) возвращает массив свойств объекта.

																																		//Массив: перебирающие методы
Современный стандарт Javascript представляет много методов для "умного" перебора массивов, которые есть в современных браузерах

//forEach(для перебор массива)
Метод "arr.forEach(callback[,thisArg])" используется для перебора массива. Он для каждого элемента массива вызывает функцию callback.
Этой функции он передает три параметра callback(item, i, arr):
item - очередной элемент массива.
i - его номер.
arr - массив, который перебирвается
Пример:
var arr = ["Яблоко", "Апельсин", "Груша"];

arr.forEach(function(item, i, arr)){
	alert(i + ":" + item + "(массив:" + arr +")" ); 
});
Второй, необязательный аргумент forEach позволяет указать контекст this для callback.
Метод forEach ничего не возвращает, его используют только для перебора, как более "элегантный" вариант, чем обычный цикл "for"

//filter(для фильтрация массива)
Метод "arr.filter(callback[,thisArg])" используется для фильтрации массива через функцию.
Он создает новый массив, в который войдут те элементы arr, для которых вызов callback(item, i, arr) возвратит true.
Пример:
var arr = [1, -1, 2, -2, 3];

var positiveArr = arr.filter(function(number){
return number > 0;
});

alert(positiveArr); // 1,2,3

//map(для трансформация массива в массив)
Метод "arr.filter(callback[,thisArg])" используется для фильтрации массива через функцию.
Он создает новый массив, который будет состоять из результатов вызова callback(item, i, arr) для каждого элемента arr.
Пример:
var names = ['HTML', 'CSS', 'Javascript'];

var nameLengths = names.map(function(name)){
	return name.length;
});

получили массив с длинами
alert(nameLengths); //4,3,10

//every/some(для проверки массива)
Эти методы используются для проверки массива
Метод "arr.every(callback[, thisArg])" возвращает true, если вызов callback вернет true для каждого элемента arr.
Метод "arr.some(callback[, thisArg])" возвращает true, если вызов callback вернет true для какого-нибудь элемента arr.
Пример:
var arr = [1, -1, 2, -2, 3];

function isPositive (number) {
	return number > 0;
}

alert(arr.every(isPositive)); //false, не все положительные
alert(arr.some(isPositive)); //true, есть хоть одно положительное

//reduce/reduceRight(для прохода по массиву с вычислением значения)
Метод "arr.reduce(callback[, initialValue])" используется для последовательной обработки каждого элемента массива с сохранением промежуточного
результата.
Метод reduce используется для вычисления на основе массива какого-либо единого значения.
Данный метод применяет функцию callback по очереди к каждому элементу массива слева направо, сохраняя при этом промежуточный результат.
Аргументы функции callback(previousValue, currentItem, index, arr):
-previousValue - последний результат вызова функции, он "промежуточный результат".
-currentItem - текущий элемент массива, элементы перебираются по очереди слева-направо
-index - номер текущего элемента.
-arr - обрабатываемый массив.
Кроме callback, методу можно передать "начальное значение" - аргумент initialValue. Если он есть, то на первом вызове значение previousValue 
будет равно initialValue, а если у reduce нет второго аргумента, то оно равно первому элементу массива, а перебор начинается со второго.

																											//Псевдомассив аргуметов "arguments"
В Javascript любая функция может быть вызвана с произвольным количеством аргументов 
Пример:
function go(a,b){
	alert("a="+a+", b="+b);
}																											 
go(1); // a=1, b=undefined
go(1,2); //a=1, b=2
go(1,2,3); //a=1, b=2, третий аргумент не вызовет ошибки

Вообще в Javascript может быть только одна функция с определенным именем, которая вызывается с любыми аргументами.

//Доступ к "лишним" аргументам
Доступ к ним осуществляется через "псевдо-массив" arguments
Он содержит список аргументов по номерам: arguments[0], arguments[1]..., а также свойство length.
Пример:(вывод список всех аргументов):
function sayHi(){
	for(var i=0; i<arguments.length; i++){
		alert("Привет, " + arguments[i]);
	}
}
sayHi("Винни", "Пятачок"); // 'Привет, Винни', 'Привет, Пятачок'
Все параметры находятся в arguments, даже если они есть в списке. Код выше сработал бы также, будь функция объявлена sayHi(a,b,c)

В современной JS аргументы отделены от локальных переменных
Пример:
function f(x) {
	"use strict"; // для браузеров с поддержкой строгого режима

	arguments[0] = 5;
	alert(x); // не 5, а 1! Переменная "отвязана" от arguments
}
f(1);
НО если мы не используем строгий режим, то чтобы переменные не менялись "неожиданно", рекомендуется никогда не изменять arguments.

arguments - это не массив, поэтому бессмысленно применять методы для Array. Вообще arguments являвяется обычным объектов, просто ключи числовые
и есть length. 

//Пример копирования свойств copy(dst,src1,src2...)
Иногда встает задача - скопировать в существующий объект свойства из одного или нескольких других.
Напишем для этого функцию copy. Она будет работать с любым числом аргументов, благодаря использованию arguments.
Cинтаксис: copy(dst, src1, src2...)
Копирует свойства из объекта src1, src2,... в объект dst. Возвращает получившийся объект
Пример: для объединения нескольких объектов в один:
var vasya = {
	age: 21,
	name: 'Вася',
	surname: 'Петров'
};

var user = {
	isAdmin: false,
	isEmailConfirmed: true
};

var student = {
	university: 'My university'
};

//добавить к vasya свойства из user и stundent
copy(vasya, user, student);

alert(vasya.isAdmin); // false
alert(vasya.university); // My university

Для создания копии объекта user:
Пример:
//скопирует все свойства в пустой объект
var userClone = clone({}, user);
Такой "клон" объекта может пригодится нам, где мы хотим изменять его свойства, при этом не трогая исходный объект user.

//Аргументы по умолчанию через ||
Если функция вызвана с меньшим количеством аргументов, чем указано, то отсутствующие аргументы считаются равными undefined.
Зачастую в случае отсутствия аргумента мы хотим присвоить ему некоторое "стандартное" значение или, иначе говоря, значение "по умолчанию"
Это можно сделать при помощи оператора логическое ИЛИ ||.
Например, функция showWarning, описанная ниже, должна показывать предупреждение. Для этого она принимает ширину width, высоту heigth,
заголовок title и содержимое contents, но большая часть этих аргументов необязательна
Пример:
function showWarning(width, height, title, contents){
	width = width || 200; // если не указана width, то width = 200
	heigth = heigth || 100;  // если нет heigth, то height = 100
	title = title || "Предупреждение";
}
Т.е. в коде выше, при передаче width = 0 или width = null, оператор ИЛИ заменит его на значение по умолчанию.
А что, если мы хотим использовать значение по умолчанию только если width === undefined? В этом случае оператор ИЛИ уже не подойдет,
нужно поставить явную проверку
Пример:
function showWarning(width, height, title, contents) {
	if(width === undefined) width = 200;
	if(height === undefined) height = 100;
	if(title === undefined) title = "Предупреждение"
}

//Именованный аргументы
Именованные аргументы - альтернативная техника работы с аргументами, которая вообще не использует arguments.
В Javascript для этих целей используется передача аргументов в виде объекта, а в его свойствах мы передаем параметри
Т.е. в тех случаях, когда возможных аргументов много и, в особенности, когда большинство их имеют значения по умолчанию вместо работы с 
arguments организуют передачу данных через объект, который как правило называют options.
Пример:
function showWarning(options){
	var width = options.width || 200;
	var height = options.height || 100;

	var contents = options.contents || "Предупреждение";
}

Вызвать такую функцию очень легко. Достаточно передать объект аргументов, указав в нем только нужные
Пример:
showWarning({
	contents: "Вы вызвали функцию" // и все понятно!
});

Еще один бонус - возможность повторного использования объекта аргументов:
Пример:
var opts = {
	width: 400,
	height: 200,
	contents: "Текст"
};

showWarning(opts);

opts.contents = "Другой текст";

showWarning(opts); // вызвать с новым текстом, без копирования других аргументов
Также возможен и гибридных вариант, при котором первый аргумент обязателен, а второй - options, который содержит всевозможные доп. параметры
Пример:
function showMessenge(text, options){
	//показать сообщение text, а настройки показа указаны в options
}

																																//Дата и время	
Для работы с датой в Javascript используется объекты Date
//Создание
Для создания нового объекта типа Date используется один из синтаксисов:

new Date()																																																														
Создает объект Date с текущей датой и временем
Пример:
var now = new Date();
alert(now);

new Date(milliseconds)
Создаст объект Date, значение которого равно количеству миллисекунд(1/1000секунды), прошедших с 1-го января 1970 года GMT +0
Пример:
//24 часа после 01.01.1970 GMT +0
var Jan02_1970 = new Date(3600 * 24 * 1000);
alert(Jan02_1970)

new Date(datestring)
Если единственный аргумент строка, то используется вызов Date.parse для чтения даты из неё.

new Date(year, month, date, hours, minutes, seconds, ms)
Дату можно создать, используя компоненты в местной временной зоне. Для этого формата обязательны только первые два аргумента.
Отсутствующие параметры, начиная с hours считаются равными нулю, а date - единице.
Заметим:
- Год year должен быть из 4 цифр.
- Отсчет месяцев month начинается с 0.
Пример:
new Date(2011, 0, 1, 0, 0, 0, 0) // 1 января 2011, 00:00:00
new Date(2011, 0, 1); // то же самое, часы/секунды по умолчанию равны 0

Дата создания с точностью до миллисекунд:
var date = new Date(2011, 0, 1, 2, 3, 4, 567)
alert (date); // 1.01.2011, 02:03:04.567

//Получение компнентов даты
Для доступа к компонентам даты-времени объекта Date используются следующие методы:
getFullYear() // получить год(из 4 цифр)
getMonth()// получить месяцев, от 0 до 11
getDate()// получить число месяца, от 1 до 31.
getHours(), getMinutes(), getSeconds(), getMilliseconds() // Получить соответсвующие компоненты
Также еще есть:
getDay() //получить номер дня в неделе. Неделя в Javascript начинается с воскресенья, так что результат будет числом от 0(воскресенье)
				//до 6(суббота)
Все методы, указанные выше, возвращают результат для местной временной зоны.
Существуют также UTC-варианты этих методов, возвращающие день, месяц, год и т.п. для зоны GMT +0(UTC):
getUTCFullYear(), getUTCMonth(), getUTCDay(). Т.е, сразу после "get" вставляется "UTC".
Т.е. если ваше локальное время сдвинуто относительно UTC, то следующий код покажет разные часы
Пример:
//текущая дата
var date = new Date();

//Час в текущей временной зоне
alert(date.getHours());
//Сколько сейчас времени в Лондоне
//час в зоне GMT+0
alert(date.getUTCHours());
Кроме описанных выше, существуют два специальных метода без UTC-варианта:
getTime() //возвращает число миллисекунд, прошедших с 1 января 1970 года GMT+0, т.е. того же вида, который используется 
					// в конструкторе new Date(milliseconds)
getTimezoneOffset() //возвращает разницу между местным и UTC-временем, в минутах
Пример:
alert(new Date().getTimezoneOffset() ); //для GMT-1 выведет 60

//Установка компонентов даты
Следующие методы позволяют установливать компоненты даты и времени:
setFullYear(year[, month, date])
setMonth(month[, date])
setDate(date)
setHours(hour[, min, sec, ms])
setMinutes(min[, sec, ms])
setSeconds(sec,[, ms])
setMilliseconds(ms)
setTime(milliseconds) (устанавливает всю дату по миллисекундам с 01.01.1970 UTC)
Все они, кроме setTime() обладают UTC-вариантом, например: setUTCHours().
Как видно, некоторые методы могут устанавливать несколько компонентов даты одновременно, в частности, setHours.
//Автоисправление даты
Автоисправление - заключается в том, что можно устанавливать заведомо некорретные компоненты(например 32 января), а объект
сам себя поправит
Пример:
var d = new Date(2013, 0, 32); //32 января 2013
alert(d); // 1 февраля 2013
Т.е. неправильные компоненты даты автоматически распределяются по остальним.
Например, нужно увеличить на 2 дня дату "28 февраля 2011". Может быть так, что это будет 2 марта, а может быть 1 марта, если год высокосный.
Но нам обо всем этом думать не нужно. Просто прибавляем два дня. Остальное сделает Date:
Пример:
var d = new Date(2011, 1, 28);
d.setDate(d.getDate() + 2);

alert(d); // 2 марта, 2011
Также это используют для получение даты, отдаленной от имеющийся на нужный промежуток времени. Например, получим дату на 70 секунд больше
текущей.
Пример:
var d = new Date();
d.setSeconds(d.getSeconds() + 70);
alert(d); // выведет корректную дату
Можно установить и нулевые, и даже отрицательные компоненты
Пример:
var d = new Date;
d.setDate(1); // поставить первое число месяца
alert(d);
d.setDate(0); // нулевого числа нет, будет последнее число предыдущего месяца
alert(d);
Или пример:
var d = new Date;
d.setDate(-1); // предпоследнее число предыдущего месяца
alert(d);

// Преобразование к числу, разность дат
Когда объект Date используется в числовом контексте, он преобразуется в количество миллисекунд:
Пример:
alert(+new Date) // +date то же самое, что: +date.valueOf()
Важный побочный эффект: даты можно вычитать, результат вычитания объектов Date - их временная разница, в миллисекундах:
Это используют для изменения времени:
var start = new Date; //засекли время
//что-то сделать
for (var i = 0; i < 10 000; i++) {
	var doSomething = i * i * i;
}

var end = new Date; // конец измерения
alert("Цикл занял " + (end - start) + " ms");

//Более точное время с perfomance.now()
В современных браузерах вызов perfomance.now() возвращает количество миллисекунд, прошедшее с начала загрузки страницы.
Причём именно с самого начала, до того, как загрузился HTML-файл, если точнее - сам момента выгрузки предыдущей страницы из памяти.
Так что это время включает в себя все, включая начальное обращение к сервера.
Его можно посмотреть в любом месте страницы, даже в <head>, чтобы узнать, сколько времени потребовалось браузеру, чтобы до него добраться, 
включая загрузку HTML
Возвращаемое значение измеряется в миллисекундах, но дополнительно имеет точность 3 знака после запятой.
Для измерение с одновременным выводом результатов в консоли есть методы:
console.time(метка) - включить внутренний хронометр браузера с меткой
console.timeEnd(метка) - выключить внутренний хронометр браузера с меткой и вывести результат
Параметр "метка" используется для идентефикации таймера, чтобы можно было делать много замеров одновременно и даже вкладывать измерения друг
в друга
Т.е. Для бенчмаркинга лучше использовать performance.now() (кроме IE9-), он в 1000 раз точнее.

//форматирование и вывод дат
Во всех браузерах, кроме IE10-, поддерживается новый стандарт Ecma 402, который добавляет специальные методы для форматирования дат.
Это делается вызовом date.toLocaleString(локаль, опции), в котором можно задать много настроек. Он позволяет указать, какие параметры даты 
нужно вывести, и ряд настроек вывода, после чего интерпретатор сам сформирует строку.

//Методы вывода без локализации:
toString(), toDateString(), toTimeString(). Возвращают стандартное строчное представление, не заданное жёстко в стандарте, 
а зависящее от браузера. Метод toString возвращает дату целиком, toDateString() и toTimeString() - только дату и время соответственно.
Есть варианты методов с UTC.
Если хочется иметь большую гибкость и кросс-браузерность, то также можно воспользоваться специальной библиотекой, например Moment.JS.

//Метод Date.now()
Метод Date.now() возвращает дату сразу в виде миллисекунд.
Технически, он аналогичен вызову +new.Date(), но в отличие от него не создает промежуточный объект даты, а поэтому - во много раз быстрее
Его использование особенно рекомендуется там, где производительность при работе с датами критична.
Обычно это не на веб-страницах, а, к примеру, в разработке игр на JavaScript.